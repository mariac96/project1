ΚΑΡΛΗΣ ΝΙΚΟΛΑΟΣ 1115201800068
ΧΑΤΖΗΠΑΥΛΟΥ ΜΑΡΙΑ 1115201400223

./lsh -i input_small_id -q query_small_id -k 10 -L 6 -o output_file -N 2 -R 20000

Δίνονται τα arguments στο command line και αν δεν δοθούν τα input ή output ή query τότε βγάζει error ενώ στα υπόλοιπα arguments χρησιμοποιώ default αν δεν δοθούν.
Έχουμε μια κλάση dVector με μελη το id του πολυσδιάστατου διανύσματος και τις συντεταγμένες του στον d-χωρο μέσω ενός vector. 
Ανοίγoυμε το input αρχείο και σε καθε γραμμη η πρώτη λέξη είναι το id του διανύσματος και τα υπόλοιπα είναι οι συντεταγμένες όπου της βάζω σε ένα vector. 
Επίσης στο πρώτο διάνυσμα μετράω και τις διαστάσεις. Έπειτα καλώ το constructor του dVector και το κάνω push στο vector dataset που έχει όλα τα διανύσματα(dVector) που διαβάζω.
Ορίζουμε το window w τυχαια με τιμές ανάμεσα στο 300 και 400 γιατί έτσι δίνει καλά αποτελέσματα.
Το TableSize είναι n/4.
Δημιουργούμε το d-vector V με την normal_distribution και με τις τιμές που μας ζητήθηκαν.
Δημιουργούμε και το 2-αστατο τυχαίο διάνυσμα t και συντεταγμένες τυχαίες τιμές μέσω της συνάρτησης uni_distribution, μεγαλύτερες του 0 και μικρότερες του w όπως λέει η εκφώνηση.
Δημιουργούμε τα k τυχαία r που είναι κοινά για όλα.
Για κάθε vector που μας δόθηκε υπολογίζουμε τα k σε αριθμό h, με την συνάρτηση hp, και τα αποθηκεύουμε στο vector hi. 
Η hp δέχεται σαν ορίσμα το w, το τυχαίο διάνυσμα V, το τυχαίο t και το d-vector.
Χρησιμοποιώ το inner_product γιατι δεν έβρισκα πως να κάνω iterate σε 2 vector ταυτόχρονα και το inner_product κάνει την πράξη για εμένα πιο εύκολα.
Με την gp συνάρτηση βρίσκω το #bucket που μπαίνει το vector που δόθηκε ως input.
Στο gp χρησιμοποιω το euclidean modulo για να βγαίνει θετικό το αποτέλεσμα. Επίσης δεν χρησιμοποιώ την ιδιότητα του modulo αφού έμαθα το inner_product.

Ανοίγουμε όμοια το query αρχείο και αποθηκεύουμε τα query vectors σε όμοια δόμη όπως το dataset.
Για κάθε vector του query dataset υπολογίζουμε τα h και gp. Το gp του query είναι το bucket των hash tables από όπου παίρνω όλα τα dvectors που είναι εκεί και υπολογίζω την ευκλείδια απόστασή τους.
Αποθηκεύω σε κάθε query τις αποστάσεις των neighbours σε ένα stl container map με την απόσταση και το ID του γειτονικού vector, για να μπορώ να εμφανίσω τα nearest neighbour. Αν η ευκλείδια απόσταση είναι μικρότερη από τo R που δόθηκε κάνω push το id σε μια λίστα με τα vectors που είναι μέσα στο range.
Υπολογίζουμε με brute force το nearest neighbours και εμφανίζουμε τα αποτελέσματα και τους χρόνους στο outputfile.